extends Area3D
class_name NetworkSync

## handles network id of scene, listing properties persisted over the network
## and serializing, deserializing them

## Network ID Scene. Persistant across the network
## This should be generated by the server and populated at creation time
var network_id : int = -1

@export var synced_vars : Array[PropertySelection]

@export var fov_importance = 0.3
@export var distance_importance = 1.0
@export var working_distance_squared = 625 # meters away
@export var last_update_time = 0 # ticks in millis since last update applied
@export var freshness_importance  = 0.6
@export var max_refresh_ticks = 10 # really don't want to wait more than 2 seconds for anything
var _update_priority = 1;
# TODO 
# @export var importance = 3

func _enter_tree():
  var is_network_id_set: bool = (network_id!=-1)
  if not is_network_id_set and Networking.is_host():
    network_id = Networking.get_network_id()

## Really, we should pass a context object and the sync should pick and choose...maybe later
func update_priority(player_global_position:Vector3 , camera_direction: Vector3):
  var object_offset = (global_position - player_global_position)
  # reset priority
  _update_priority = 0
  # Is the object close by?
  var distance_metric = clampf (working_distance_squared / object_offset.length_squared(), 0 , 1)
  _update_priority += distance_metric * distance_importance
  # Are we facing the object?
  var fov_metric = camera_direction.dot(object_offset.normalized())
  _update_priority += fov_metric * fov_importance
  # prioritize things that have not been updated in a while
  var update_freshness = clampf ( float( Time.get_ticks_msec() - last_update_time) / float(max_refresh_ticks) , 0 , 1 )
  _update_priority += update_freshness * freshness_importance
  
func get_update_priority():
  return _update_priority

func refresh():
  last_update_time = Time.get_ticks_msec()

## An update is composed of a 2 level Dictionary
## { NodePath : { PropertyName : PropertyValue } }
## So, a list of all the affected nodes, and each contains a 
## map of their properties to values (Basically a simplified scene tree)
## is actually type of Dictionary[NodePath , Dictionary], but type erasure makes hard to check
func create_update() -> Dictionary:
  var scene_updates = {}
  # go through each tracked node
  for selection in synced_vars:
    # Get the properties and values for each node
    var prop_updates = {}
    for prop in selection.props:
      # Store all the values of all the properties
      var val = get_node(selection.node).get(prop)
      prop_updates[prop]= val
    # Associate those properties back to the nodepath it belongs to
    scene_updates[selection.node] = prop_updates
  return scene_updates
  
## Apply updates created with create_update() method
## is actually type of Dictionary[NodePath , Dictionary], but type erasure makes hard to check
func apply_update(scene_updates : Dictionary):
  for update_node_path in scene_updates.keys():
    # Get the properties that belong to this node
    var update_properties = scene_updates[update_node_path] as Dictionary
    # Get the actual node from the node path
    var update_node = get_node(update_node_path)
    # Update each property with it's value
    for prop_name in update_properties.keys():
      var prop_value = update_properties[prop_name]
      update_node.set(prop_name, prop_value)
